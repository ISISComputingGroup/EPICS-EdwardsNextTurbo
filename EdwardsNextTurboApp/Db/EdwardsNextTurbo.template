#! Generated by VisualDCT v2.6
#! DBDSTART
#! DBD("../../dbd/EdwardsNextTurbo.dbd")
#! DBDEND

# SVCLOWHR 	The number of hours remaining to service before it is considered a warning should be given.
#		Applied to all service records with units of hours.
#		Optional macro - defaults to 48.
# SVCLOLOHR	The number of hours remaining to service before it is considered an error.
#		Applied to all service records with units of hours.
#		Optional macro - defaults to 0.
# SVCLOWCYCL 	The number of cycles remaining to service before it is considered a warning should be given.
#		Applied to all service records with units of cycles.
#		Optional macro - defaults to 20.
# SVCLOLOCYCL	The number of cycles remaining to service before it is considered an error.
#		Applied to all service records with units of cycles.
#		Optional macro - defaults to 0.
# MTRTEMPLOW    The motor temperature low limit at which it is considered an alarm should be raised in degrees Celsius.
#		Optional macro - defaults to 1 - don't suppose we want it to freeze.
# MTRTEMPHIGH   The motor temperature high limit at which it is considered an alarm should be raised in degrees Celsius.
#		Optional macro - defaults to 90 - the range is given in the manual as 0-100.  Motors can get hotter than this - not sure what to put.
# CTLRTEMPLOW   The internal temperature of the controller low limit at which it is considered an alarm should be raised in degrees Celsius.
#		Optional macro - defaults to 1 - don't suppose we want it to freeze either.
# CTLRTEMPHIGH  The internal temperature of the controller high limit at which it is considered an alarm should be raised in degrees Celsius.
#		Optional macro - defaults to 70 - the range is given in the manual as 0-100.  This is about where we get wobbly over a hot IOC.
# VVENTENABLE	Binary to indicate whether the system has a vent valve on it.  Enables  display of vent valve widgets on the GUI. 0 - Disable, 1 - Enable.
#		Optional macro - defaults to 0, Disable
#

#########################################################
# START OF RECORDS FOR SCANNING CONTROL
#
# % autosave 1 VAL
# This record needed to stop various records scanning and generating lots
# of error messages if the box is unplugged - this tends to be needed
# for end station IOCs.
record(bo, "$(P):DISABLE") {
  field(DESC, "Disable comms")
  field(PINI, "YES")
  field(VAL, "$(DISABLED=0)")
  field(OMSL, "supervisory")
  field(ZNAM, "Enabled")
  field(ONAM, "Disabled")
}

# To provide PINI control.  The info retrieved on initialisation - stuff that's useful
# to know, but should not change.  Also used for some refresh buttons.
#
record(fanout, "$(P):FAN:PINI1") {
  field(DESC, "PINI fanout 1")
  field(SCAN, "Passive")
  field(PINI, "YES")
  field(LNK1, "$(P):FAN:SVC:ALL")
}

# To provide control over the scanning rate of the "faster changing" stuff.
record(fanout, "$(P):FAN:SCAN1") {
  field(DESC, "Fast scan fanout")
  field(SCAN, "1 second")
  field(SDIS, "$(P):DISABLE")
  field(LNK1, "$(P):GET:SPEEDSTATUS")
}

# To provide control over the scanning rate of the "slowly changing" stuff, temperatures and times.
record(fanout, "$(P):FAN:SCAN2") {
  field(DESC, "Slow scan fanout")
  field(SCAN, "10 second")
  field(SDIS, "$(P):DISABLE")
  field(LNK1, "$(P):RBV:NORMALSPEED:PC")
  field(LNK2, "$(P):RBV:STANDBYSPEED:PC")
  field(LNK3, "$(P):GET:TEMPSTATUS")
  field(LNK4, "$(P):GET:ELECSTATUS")
  field(LNK5, "$(P):FAN:TIMEOUT:ALL")
  field(LNK6, "$(P):RBV:POWER:MAX")
  field(FLNK, "$(P):RBV:HEXSTS PP")
}

# END OF RECORDS FOR SCANNING CONTROL
#########################################################

# Record to run all the commands to collection version information.
record(fanout, "$(P):FAN:VSN:ALL") {
  field(DESC, "Version fanout.")
  field(SCAN, "Passive")
  field(LNK1, "$(P):GET:VSN:MODEL")
  field(LNK2, "$(P):VSN:BOOT")
}

#########################################################
# START OF RECORDS FOR READBACK FROM VERSION COMMAND.
#
# # Readback of the instrument model and version info.
# # Run the Version command, V.
# # The string was too long to put model and version into same record.
# # Scan this once, probably not needed again.
# The reply comes back and is split amongst other records.
record(stringin, "$(P):GET:VSN:MODEL") {
  field(DESC, "Get Version")
  field(DTYP, "stream")
  field(INP,  "@EdNxtT.proto getVersionModel($(P)) $(port)")
  field(SCAN, "Passive")
  field(FLNK, "$(P):FAN:VSN:MODEL.PROC PP MS")
}

# Fans out the processing for all the records handling reply from
# get version model command.
record(fanout, "$(P):FAN:VSN:MODEL") {
  field(DESC, "Version info fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):VSN:MODEL PP MS")
  field(LNK2, "$(P):VSN:DSP PP MS")
  field(LNK3, "$(P):VSN:FULLSPEED:RPS PP MS")
}

record(stringin, "$(P):VSN:MODEL") {
  field(DESC, "Model.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
}

record(stringin, "$(P):VSN:DSP") {
  field(DESC, "Firmware version.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
}

record(ai, "$(P):VSN:FULLSPEED:RPS") {
  field(DESC, "Designated Full Speed of Model.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "RPS")
  field(PREC, "0")
}

# END OF RECORDS FOR READBACK FROM VERSION COMMAND.
#########################################################
# START OF RECORDS FOR DIRECT READBACK.
#
# The bootloader version information.
#
record(stringin, "$(P):VSN:BOOT") {
  field(DESC, "Get Boot loader version")
  field(DTYP, "stream")
  field(INP,  "@EdNxtT.proto getVersionBoot $(port)")
  field(SCAN, "Passive")
}

# % archiver 10 monitor
record(ai, "$(P):RBV:NORMALSPEED:PC") {
  field(DESC, "Normal Speed Setting Readback")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getNormalSpeed $(port)")
  field(EGU,  "%")
  field(LOPR, "0")
  field(HOPR, "100")
  field(LOLO, "49.999")
  field(HIHI, "100.001")
  field(LLSV, "MINOR")
  field(HHSV, "INVALID")
  field(PREC, "0")
  field(ADEL, "1" )
  field(FLNK, "$(P):TFM:SPEEDS:PCTORPS.PROC PP MS")
}

# % archiver 10 monitor
record(ai, "$(P):RBV:STANDBYSPEED:PC") {
  field(DESC, "Standby Speed Setting Readback")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getStandbySpeed $(port)")
  field(EGU,  "%")
  field(LOPR, "0")
  field(HOPR, "100")
  field(LOLO, "54.999")
  field(HIHI, "100.001")
  field(LLSV, "MINOR")
  field(HHSV, "INVALID")
  field(PREC, "0")
  field(ADEL, "1" )
  field(FLNK, "$(P):TFM:SPEEDS:PCTORPS.PROC PP MS")
}

# Needed this for debugging.
record(stringin, "$(P):RBV:HEXSTS") {
  field(DESC, "Status String Readback")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getHexSts $(port)")
}

# Make scan control easier by fanning out at this level to all the timeout stuff.
record(fanout, "$(P):FAN:TIMEOUT:ALL") {
  field(DESC, "Timeout scanning fanout.")
  field(SCAN, "Passive")
  field(LNK1, "$(P):RBV:TIMEOUT:PERIOD")
  field(LNK2, "$(P):RBV:TIMEOUT:ENABLED")
}

# Length of the timeout period in minutes - how long to achieve the target speed
# before it is considered an error.
# This is the device ramping timeout, nothing to do with comms.
record(ai, "$(P):RBV:TIMEOUT:PERIOD") {
  field(DESC, "Timeout period (minutes).")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getTimeoutPrd $(port)")
  field(EGU,  "MIN")
  field(LOPR, "0")
  field(HOPR, "30")
  field(LOLO, "0.999")
  field(HIHI, "30.001")
  field(LLSV, "INVALID")
  field(HHSV, "INVALID")
  field(PREC, "0")
}

# Flag for whether the timeout is enabled or disabled.  It is always enabled during ramping
# but it can be enabled for other purposes.  We now provide a facility to do
# this.
record(bi, "$(P):RBV:TIMEOUT:ENABLED") {
  field(DESC, "Timeout enabled readback")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getTimeoutEna $(port)")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
}

# Value of the power limit.  Range 50-200W, defaults to 60W.
record(ai, "$(P):RBV:POWER:MAX") {
  field(DESC, "Power maximum limit readback")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getPowerMax $(port)")
  field(EGU,  "W")
  field(LOPR, "0")
  field(HOPR, "200")
  field(LOLO, "49.999")
  field(HIHI, "200.001")
  field(LLSV, "INVALID")
  field(HHSV, "INVALID")
}

# END OF RECORDS FOR DIRECT READBACK.
#########################################################
# Record to run command to get the motor speed and system status parameters.
# The reply comes back to the STS records.
record(ai, "$(P):GET:SPEEDSTATUS") {
  field(DESC, "Get motor speed and system status.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSpeedSts($(P)) $(port)")
  field(FLNK, "$(P):FAN:SPEEDSTATUS PP MS")
}

# Fans out the processing for all the records handling reply from
# speed status command.
record(fanout, "$(P):FAN:SPEEDSTATUS") {
  field(DESC, "Speed and system status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):STS:MOTORSPEED:RPS PP MS")
  field(LNK2, "$(P):STS:SYSTEMSTATUS PP MS")
}

# % archiver 10 monitor
# Current Motor speed.
record(ai, "$(P):STS:MOTORSPEED:RPS") {
  field(DESC, "Motor Speed (Rev. Per Sec)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "RPS")
  field(PREC, "0")
  field(FLNK, "$(P):CLC:MOTORSPEED:RPSTOPC.PROC PP MS")
}

# System Status word.  The processing is forwarded onto a 
# transform record to mangle the bits.
record(ai, "$(P):STS:SYSTEMSTATUS") {
  field(DESC, "System Status Word")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(FLNK, "$(P):TFM:SYSTEMSTATUS.PROC PP MS")
}

# -------------------------------------------------------------------
# START OF TEMPERATURE STATUS.
#
# Record to run command to get the temperature status parameters.
# The reply comes back to the STS records.
record(ai, "$(P):GET:TEMPSTATUS") {
  field(DESC, "Get motor and controller temperature.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getTempSts($(P)) $(port)")
  field(FLNK, "$(P):FAN:TEMPSTATUS PP MS")
}

# Fans out the processing for all the records handling reply from
# temperature status command.
record(fanout, "$(P):FAN:TEMPSTATUS") {
  field(DESC, "Temperature status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):STS:MOTORTEMP PP MS")
  field(LNK2, "$(P):STS:CONTROLLERTEMP PP MS")
}

# % archiver 10 monitor
# Motor temperature.
record(ai, "$(P):STS:MOTORTEMP") {
  field(DESC, "Motor temperature (C)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "degC")
  field(LOPR, "0")
  field(HOPR, "100")
  field(LOLO, "-0.001")
  field(HIHI, "100.001")
  field(LLSV, "INVALID")
  field(HHSV, "INVALID")
  field(LOW, "$(MTRTEMPLOW=1)")
  field(HIGH, "$(MTRTEMPHIGH=90)")
  field(LSV, "MAJOR")
  field(HSV, "MAJOR")
}

# Controller temperature.
record(ai, "$(P):STS:CONTROLLERTEMP") {
  field(DESC, "Controller temperature (C)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "degC")
  field(LOPR, "0")
  field(HOPR, "100")
  field(LOLO, "-0.001")
  field(HIHI, "100.001")
  field(LLSV, "INVALID")
  field(HHSV, "INVALID")
  field(LOW, "$(CTLRTEMPLOW=1)")
  field(HIGH, "$(CTRLRTEMPHIGH=70)")
  field(LSV, "MAJOR")
  field(HSV, "MAJOR")
}

# END OF TEMPERATURE STATUS.
# -------------------------------------------------------------------
# START OF ELECTRICAL STATUS

# Record to run command to get the electrical status parameters.
# The reply comes back to the STS records.
record(ai, "$(P):GET:ELECSTATUS") {
  field(DESC, "Get motor electrical status.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getElecSts($(P)) $(port)")
  field(FLNK, "$(P):FAN:ELECSTATUS PP MS")
}

# Fans out the processing for all the records handling reply from
# electrical status command.
record(fanout, "$(P):FAN:ELECSTATUS") {
  field(DESC, "Electrical status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):STS:DVOLTAGE PP MS")
  field(LNK2, "$(P):STS:DCURRENT PP MS")
  field(LNK3, "$(P):STS:DPOWER PP MS")
  field(FLNK, "$(P):TFM:ELECSTATUS PP MS")
}

# Voltage - values is in units of 0.1 Volts.
record(ai, "$(P):STS:DVOLTAGE") {
  field(DESC, "Voltage (0.1 V)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "dV")
  field(LOPR, "0")
  field(HOPR, "500")
}

# Current - value is in units of 0.1 Amps.
record(ai, "$(P):STS:DCURRENT") {
  field(DESC, "Current (0.1 A)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "dA")
  field(LOPR, "0")
  field(HOPR, "300")
}

# Power - value is in units of 0.1 Watts.
record(ai, "$(P):STS:DPOWER") {
  field(DESC, "Electrical Power (0.1 W)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "dW")
  field(LOPR, "0")
  field(HOPR, "1500")
}

# Conversion of electrical status from deci units to full units.
record(transform, "$(P):TFM:ELECSTATUS") {
  field(SCAN, "Passive")
  field(CMTA, "Voltage tenths input.")
  field(INPA, "$(P):STS:DVOLTAGE")
  field(CMTB, "Current tenths input.")
  field(INPB, "$(P):STS:DCURRENT")
  field(CMTC, "Power tenths input.")
  field(INPC, "$(P):STS:DPOWER")
  field(CMTD, "Voltage unit conversion.")
  field(CLCD, "A/10")
  field(OUTD, "$(P):STS:VOLTAGE PP MS")
  field(CMTE, "Current unit conversion.")
  field(CLCE, "B/10")
  field(OUTE, "$(P):STS:CURRENT PP MS")
  field(CMTF, "Power unit conversion.")
  field(CLCF, "C/10")
  field(OUTF, "$(P):STS:POWER PP MS")
}

# % archiver 10 monitor
# Voltage - values is in units of Volts.
record(ai, "$(P):STS:VOLTAGE") {
  field(DESC, "Voltage (V)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "V")
  field(PREC, "1")
  field(LOPR, "0")
  field(HOPR, "50")
}

# % archiver 10 monitor
# Current - value is in units of Amps.
record(ai, "$(P):STS:CURRENT") {
  field(DESC, "Current (A)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "A")
  field(PREC, "1")
  field(LOPR, "0")
  field(HOPR, "30")
}

# % archiver 10 monitor
# Power - value is in units of Watts.
record(ai, "$(P):STS:POWER") {
  field(DESC, "Electrical Power (W)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "W")
  field(PREC, "1")
  field(LOPR, "0")
  field(HOPR, "1500")
}

# END OF ELECTRICAL STATUS.
# -------------------------------------------------------------------
# START OF SERVICE STATUS.

# Fans out the processing all the records to get the service data.
# It is invoked from the PINI fanout at the top of the file.
# It provides control for refreshing service data manually.
# This was originally passive and driven by a manual gui button.
# Have now changed this to scan because more emphasis is being put
# on the servicing parameters - the beamline want the status displayed on 
# the End Station synoptic.
record(fanout, "$(P):FAN:SVC:ALL") {
  field(DESC, "All service fanout")
  field(SCAN, "10 second")
  field(LNK1, "$(P):GET:SVC:SVCSTATUS")
  field(LNK2, "$(P):GET:SVC:CTLR")
  field(LNK3, "$(P):GET:SVC:PUMP")
  field(LNK4, "$(P):GET:SVC:CYCLE")
  field(LNK5, "$(P):GET:SVC:BEARING")
  field(LNK6, "$(P):GET:SVC:OIL")
  field(FLNK, "$(P):FAN:VSN:ALL PP")
}

# Record to run command to get the controller service status summary.
# The reply comes back to the SVC record.
# Section 5.5.2 on p. 71 of Instruction Manual RevC.
record(ai, "$(P):GET:SVC:SVCSTATUS") {
  field(DESC, "Get service summary.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSvcSts($(P)) $(port)")
  field(FLNK, "$(P):SVC:SVCSTATUS PP MS")
}

# The service status summary word.
record(ai, "$(P):SVC:SVCSTATUS") {
  field(DESC, "Ctlr run time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
#  field(FLNK, "$(P):TFM:SVCSTATUS PP MS") 
}

# Record to run command to get the controller service parameters.
# The reply comes back to the SVC records.
# Section 5.5.4 on p. 72 of Instruction Manual RevC.
record(ai, "$(P):GET:SVC:CTLR") {
  field(DESC, "Get ctlr run, service time.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSvcCtlr($(P)) $(port)")
  field(FLNK, "$(P):FAN:SVC:CTLR PP MS")
}

# Fans out the processing for all the records handling reply from
# controller service status command.
record(fanout, "$(P):FAN:SVC:CTLR") {
  field(DESC, "Ctlr service status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):SVC:RUNTIME:CTLR PP MS")
  field(LNK2, "$(P):SVC:SVCTIME:CTLR PP MS")
}

# How many hours controller in operation.
record(ai, "$(P):SVC:RUNTIME:CTLR") {
  field(DESC, "Ctlr run time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
}

# How many hours before controller service recommended.
record(ai, "$(P):SVC:SVCTIME:CTLR") {
  field(DESC, "Ctlr service time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
  field(LOW,  "$(SVCLOWHR=48)")
  field(LSV,  "MINOR")
  field(LOLO, "$(SVCLOLOHR=0)")
  field(LLSV, "MAJOR")
}

# Record to run command to get the pump time service status parameters.
# The reply comes back to the SVC records.
# Section 5.5.4 on p. 72 of Instruction Manual RevC.
record(ai, "$(P):GET:SVC:PUMP") {
  field(DESC, "Get pump run, service time.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSvcPump($(P)) $(port)")
  field(FLNK, "$(P):FAN:SVC:PUMP PP MS")
}

# Fans out the processing for all the records handling reply from
# pump service time status command.
record(fanout, "$(P):FAN:SVC:PUMP") {
  field(DESC, "Pump service status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):SVC:RUNTIME:PUMP PP MS")
  field(LNK2, "$(P):SVC:SVCTIME:PUMP PP MS")
}
# Record to indicate whether start/stop button should be displayed in GUI.
# Hiding the GUI buttons is the strongest permission control we are using - 
# it is still possible from the database and the controller will reject 
# the command if not allowed.
record(bi, "$(P):PMS:STARTSTOPENABLE") {
  field(DESC, "Start/Stop Enable.")
  field(SCAN, "Passive")
  field(VAL, "0")
  field(PINI, "YES")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
}

# How many hours pump in operation since start up.
record(ai, "$(P):SVC:RUNTIME:PUMP") {
  field(DESC, "Pump run time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
}

# How many hours before pump service required.
record(ai, "$(P):SVC:SVCTIME:PUMP") {
  field(DESC, "Pump service time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
  field(LOW,  "$(SVCLOWHR=48)")
  field(LSV,  "MINOR")
  field(LOLO, "$(SVCLOLOHR=0)")
  field(LLSV, "MAJOR")
}

# Record to run command to get the pump cycle service status parameters.
# The reply comes back to the SVC records.
# Section 5.5.4 on p. 72 of Instruction Manual RevC.
record(ai, "$(P):GET:SVC:CYCLE") {
  field(DESC, "Get pump run, service cycles.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSvcCycle($(P)) $(port)")
  field(FLNK, "$(P):FAN:SVC:CYCLE PP MS")
}

# Fans out the processing for all the records handling reply from
# pump cylce service status command.
record(fanout, "$(P):FAN:SVC:CYCLE") {
  field(DESC, "Pump service cycles fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):SVC:RUNCYCLE:PUMP PP MS")
  field(LNK2, "$(P):SVC:SVCCYCLE:PUMP PP MS")
}

# How many start-stop cycles pump has done.
record(ai, "$(P):SVC:RUNCYCLE:PUMP") {
  field(DESC, "Pump run cycles")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "CYCLE")
}

# How many start-stop cylces before pump service required.
record(ai, "$(P):SVC:SVCCYCLE:PUMP") {
  field(DESC, "Pump service cycles")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "CYCLE")
  field(LOW,  "$(SVCLOWCYCL=20)")
  field(LSV,  "MINOR")
  field(LOLO, "$(SVCLOLOCYCL=0)")
  field(LLSV, "MAJOR")
}

# Record to run command to get the bearing time service status parameters.
# The reply comes back to the SVC records.
# Section 5.5.6 on p. 73 of Instruction Manual RevC.
record(ai, "$(P):GET:SVC:BEARING") {
  field(DESC, "Get bearing run, service time.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSvcBrng($(P)) $(port)")
  field(FLNK, "$(P):FAN:SVC:BEARING PP MS")
}

# Fans out the processing for all the records handling reply from
# bearing service status command.
record(fanout, "$(P):FAN:SVC:BEARING") {
  field(DESC, "Bearing service status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):SVC:RUNTIME:BEARING MS")
  field(LNK2, "$(P):SVC:SVCTIME:BEARING MS")
}

# How many hours bearing in operation.
record(ai, "$(P):SVC:RUNTIME:BEARING") {
  field(DESC, "Bearing run time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
}

# How many hours before bearing service recommended.
record(ai, "$(P):SVC:SVCTIME:BEARING") {
  field(DESC, "Bearing service time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
  field(LOW,  "$(SVCLOWHR=48)")
  field(LSV,  "MINOR")
  field(LOLO, "$(SVCLOLOHR=0)")
  field(LLSV, "MAJOR")
}

# Record to run command to get the oil cartridge time service status parameters.
# The reply comes back to the SVC records.
# Section 5.5.7 on p. 73 of Instruction Manual RevC.
record(ai, "$(P):GET:SVC:OIL") {
  field(DESC, "Get oil run, service time.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(INP,  "@EdNxtT.proto getSvcOil($(P)) $(port)")
  field(FLNK, "$(P):FAN:SVC:OIL PP MS")
}

# Fans out the processing for all the records handling reply from
# oil service status command.
record(fanout, "$(P):FAN:SVC:OIL") {
  field(DESC, "Oil service status fanout")
  field(SCAN, "Passive")
  field(LNK1, "$(P):SVC:RUNTIME:OIL PP MS")
  field(LNK2, "$(P):SVC:SVCTIME:OIL PP MS")
}

# How many hours oil cartridge in operation.
record(ai, "$(P):SVC:RUNTIME:OIL") {
  field(DESC, "Oil run time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
}

# How many hours before oil service recommended.
record(ai, "$(P):SVC:SVCTIME:OIL") {
  field(DESC, "Oil service time (hrs)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "HR")
  field(LOW,  "$(SVCLOWHR=48)")
  field(LSV,  "MINOR")
  field(LOLO, "$(SVCLOLOHR=0)")
  field(LLSV, "MAJOR")
}

# END OF SERVICE STATUS
# -------------------------------------------------------------------
#################################################################
# START OF RECORDS TO MANGLE SYSTEM STATUS WORDS.
#
# It actually provides 32 bits, but the Instruction Manual says the upper
# 16 are reserved for Edwards and gives no explanation as to
# what they mean.
# See Table 30 in section 5.5.9 on p. 75 of the Instruction Manual RevC.
# Using P for the input because the expressions are evaluated in
# order A-P and we need all 16 outputs.
#
# We are using bit shifting and then masking here - maybe should be masking and dividing to
# be on the safe side.
record(transform, "$(P):TFM:SYSTEMSTATUS") {
  field(INPP, "$(P):STS:SYSTEMSTATUS")
  field(SCAN, "Passive")
  field(CMTA, "Bit 0: Failed.")
  field(CMTB, "Bit 1: Motor below stopped speed.")
  field(CMTC, "Bit 2: Motor at normal speed.")
  field(CMTD, "Bit 3: Vent valve closed.")
  field(CMTE, "Bit 4: Starting.")
  field(CMTF, "Bit 5: Serial enable active.")
  field(CMTG, "Bit 6: Standby active.")
  field(CMTH, "Bit 7: Motor above half speed.")
  field(CMTI, "Bit 8: Parallel control mode.")
  field(CMTJ, "Bit 9: Serial control mode.")
  field(CMTK, "Bit 10: Invalid controller software.")
  field(CMTL, "Bit 11: Incomplete config upload.")
  field(CMTM, "Bit 12: Timer expird - not half speed.")
  field(CMTN, "Bit 13: Hware trip - Ovrspeed/current.")
  field(CMTO, "Bit 14: Thermistor error.")
  field(CMTP, "Bit 15: Serial control mode interlock.")
  field(CLCA, "P&1")
  field(CLCB, "(P>>1)&1")
  field(CLCC, "(P>>2)&1")
  field(CLCD, "(P>>3)&1")
  field(CLCE, "(P>>4)&1")
  field(CLCF, "(P>>5)&1")
  field(CLCG, "(P>>6)&1")
  field(CLCH, "(P>>7)&1")
  field(CLCI, "(P>>8)&1")
  field(CLCJ, "(P>>9)&1")
  field(CLCK, "(P>>10)&1")
  field(CLCL, "(P>>11)&1")
  field(CLCM, "(P>>12)&1")
  field(CLCN, "(P>>13)&1")
  field(CLCO, "(P>>14)&1")
  field(CLCP, "(P>>15)&1")
  field(OUTA, "$(P):STS:SYSTEMSTATUS:FAILED PP MS")
  field(OUTB, "$(P):STS:SYSTEMSTATUS:STOPPED PP MS")
  field(OUTC, "$(P):STS:SYSTEMSTATUS:NORMAL PP MS")
  field(OUTD, "$(P):STS:SYSTEMSTATUS:VENTCLOSED PP MS")
  field(OUTE, "$(P):STS:SYSTEMSTATUS:STARTING PP MS")
  field(OUTF, "$(P):STS:SYSTEMSTATUS:SERIALENA PP MS")
  field(OUTG, "$(P):STS:SYSTEMSTATUS:STANDBY PP MS")
  field(OUTH, "$(P):STS:SYSTEMSTATUS:HALF PP MS")
  field(OUTI, "$(P):STS:SYSTEMSTATUS:PARALLEL PP MS")
  field(OUTJ, "$(P):STS:SYSTEMSTATUS:SERIALCTRL PP MS")
  field(OUTK, "$(P):STS:SYSTEMSTATUS:CONTROLLERSW PP MS")
  field(OUTL, "$(P):STS:SYSTEMSTATUS:UPLOAD PP MS")
  field(OUTM, "$(P):STS:SYSTEMSTATUS:TIMER PP MS")
  field(OUTN, "$(P):STS:SYSTEMSTATUS:HWTRIP PP MS")
  field(OUTO, "$(P):STS:SYSTEMSTATUS:THERMISTOR PP MS")
  field(OUTP, "$(P):STS:SYSTEMSTATUS:SERIALILK PP MS")
  # Finally forward link record to handle upper 16 bits of 32 bit status word.
  field(FLNK, "$(P):CLC:SYSTEMSTATUS:RESERVED PP MS")
}

# System Status Bit 0.
record(bi, "$(P):STS:SYSTEMSTATUS:FAILED") {
  field(DESC, "Failed?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Failed")
  field(ONAM, "Failed")
}

# System Status Bit 1.
record(bi, "$(P):STS:SYSTEMSTATUS:STOPPED") {
  field(DESC, "Below Stopped Speed?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Stopped")
  field(ONAM, "Stopped")
}

# System Status Bit 2.
record(bi, "$(P):STS:SYSTEMSTATUS:NORMAL") {
  field(DESC, "At Normal Speed?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Normal")
  field(ONAM, "Normal")
}

# System Status Bit 3.
record(bi, "$(P):STS:SYSTEMSTATUS:VENTCLOSED") {
  field(DESC, "Vent Valve Closed?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Open")
  field(ONAM, "Closed")
}

# Record to indicate whether the system has a vent valve on it.
# Disables the vent valve GUI widgets.
# Record to indicate whether start/stop button should be displayed in GUI.
# Hiding the GUI buttons is the strongest permission control we are using - 
# it is still possible from the database and the controller will reject 
# the command if not allowed.
record(bi, "$(P):PMS:VENTENABLE") {
  field(DESC, "Vent Valve Enable.")
  field(SCAN, "Passive")
  field(VAL, "$(VVENTENABLE=0)")
  field(PINI, "YES")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
}

# System Status Bit 4.
record(bi, "$(P):STS:SYSTEMSTATUS:STARTING") {
  field(DESC, "Start In Progress?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Starting")
  field(ONAM, "Starting")
}

# System Status Bit 5.
record(bi, "$(P):STS:SYSTEMSTATUS:SERIALENA") {
  field(DESC, "Serial Enable Control Active?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Serial Disabled")
  field(ONAM, "Serial Enabled")
}


# System Status Bit 6.
record(bi, "$(P):STS:SYSTEMSTATUS:STANDBY") {
  field(DESC, "Standby Active?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Standing By")
  field(ONAM, "Standing By")
}

# System Status Bit 7.
record(bi, "$(P):STS:SYSTEMSTATUS:HALF") {
  field(DESC, "At >= Half Speed?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Below Half Speed")
  field(ONAM, "At/Above Half Speed")
}

# System Status Bit 8.
record(bi, "$(P):STS:SYSTEMSTATUS:PARALLEL") {
  field(DESC, "Parallel Control Mode?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Parallel Control Mode")
  field(ONAM, "Parallel Control Mode")
}

# System Status Bit 9.
record(bi, "$(P):STS:SYSTEMSTATUS:SERIALCTRL") {
  field(DESC, "Serial Control Mode?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Not Serial Control Mode")
  field(ONAM, "Serial Control Mode")
}

# System Status Bit 10.
record(bi, "$(P):STS:SYSTEMSTATUS:CONTROLLERSW") {
  field(DESC, "Controller Software Mismatch?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "OK")
  field(ONAM, "Mismatch")
}

# System Status Bit 11.
record(bi, "$(P):STS:SYSTEMSTATUS:UPLOAD") {
  field(DESC, "Configuration Upload Incomplete?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Complete")
  field(ONAM, "Incomplete")
}

# System Status Bit 12.
record(bi, "$(P):STS:SYSTEMSTATUS:TIMER") {
  field(DESC, "Timer Expired?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "OK")
  field(ONAM, "Expired")
}

# System Status Bit 13.
record(bi, "$(P):STS:SYSTEMSTATUS:HWTRIP") {
  field(DESC, "Overspeed/Overcurrent Trip?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "OK")
  field(ONAM, "Tripped")
}

# System Status Bit 14.
record(bi, "$(P):STS:SYSTEMSTATUS:THERMISTOR") {
  field(DESC, "Thermistor Error?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "OK")
  field(ONAM, "Error")
}

# System Status Bit 15.
record(bi, "$(P):STS:SYSTEMSTATUS:SERIALILK") {
  field(DESC, "Serial Mode Interlock?")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZNAM, "Active")
  field(ONAM, "Inactive")
}

# EDM widget does not like shifting 6 bits on a 32 bit decimal - will only allow 15 - sign?
# Therefore grab the second part of the work into a separate record.
# We do not know what these bits mean, so we won't bother to transform them, but might be useful
# if ever there is a problem.
record(calc, "$(P):CLC:SYSTEMSTATUS:RESERVED") {
  field(DESC, "Edwards Reserved Status Word.")
  field(SCAN, "Passive")
  field(INPA, "$(P):STS:SYSTEMSTATUS")
  field(CALC, "A>>16")
}

# END OF RECORDS TO MANGLE SYSTEM STATUS WORDS.
#################################################################
# START OF RECORDS TO SET STUFF.
#

# % autosave 1 VAL
# Set the normal speed setting value.  Allowed range 50-100% (percentage of full speed).
# Forward link to process return code record.
record(ao, "$(P):SET:NORMALSPEED") {
  field(DESC, "Set Normal Speed Percent.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@EdNxtT.proto setNormalSpeed($(P)) $(port)")
  field(EGU,  "%")
  field(LOPR, "0")
  field(HOPR, "100")
  field(LOLO, "49.999")
  field(HIHI, "100.001")
  field(LLSV, "MINOR")
  field(HHSV, "INVALID")
  field(PREC, "0")
  field(FLNK, "$(P):RTN:LASTCMD.PROC PP MS")
}

# % autosave 1 VAL
# Set the standby speed setting value.  Allowed range 55-100% (percentage of full speed).
record(ao, "$(P):SET:STANDBYSPEED") {
  field(DESC, "Set Standby Speed Percent.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@EdNxtT.proto setStandbySpeed($(P)) $(port)")
  field(EGU,  "%")
  field(LOPR, "0")
  field(HOPR, "100")
  field(LOLO, "54.999")
  field(HIHI, "100.001")
  field(LLSV, "MINOR")
  field(HHSV, "INVALID")
  field(PREC, "0")
  field(FLNK, "$(P):RTN:LASTCMD.PROC PP MS")
}

# Set Length of the timeout period in minutes - how long to achieve the target speed
# before it is considered an error.
# This is the device ramping timeout, nothing to do with comms.
record(ao, "$(P):SET:TIMEOUT:PERIOD") {
  field(DESC, "Set Timeout period (minutes).")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@EdNxtT.proto setTimeoutPrd($(P)) $(port)")
  field(EGU,  "MIN")
  field(LOPR, "0")
  field(HOPR, "30")
  field(LOLO, "0.999")
  field(HIHI, "30.001")
  field(LLSV, "INVALID")
  field(HHSV, "INVALID")
  field(PREC, "0")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# Set the flag for whether the timeout is enabled or disabled.  It is always enabled during ramping
# but it can be enabled for other purposes.  Use this with caution - you are starting a timeout countdown.
record(bo, "$(P):SET:TIMEOUT:ENABLED") {
  field(DESC, "Set Timeout enabled - Caution.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@EdNxtT.proto setTimeoutEna($(P)) $(port)")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# END OF RECORDS TO SET STUFF.
##################################################################
# START OF RECORDS TO DO STUFF.
# i.e. activity, make the pump change its state.
# NOTE: There is no command to make the pump "Go to normal speed."
# Normal speed is a level indicator which is passed on the
# way to full speed (or standby speed).
# The pump ramps upto speed in much less time than it slows down
# by the same amount.  This is because motor power is applied to
# increase the speed, but the motor is simply turned off and
# the blades gradually slow down by resistance i.e. there is no
# braking.

# Start the pump - this tells it to rev up to speed.
record(bo, "$(P):ACN:STARTPUMP") {
  field(DESC, "Start pump action.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(VAL, "1")
  field(OUT,  "@EdNxtT.proto doStartPump($(P)) $(port)")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# Stop the pump - rev down from current speed to stop.
record(bo, "$(P):ACN:STOPPUMP") {
  field(DESC, "Stop pump action.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(VAL, "0")
  field(OUT,  "@EdNxtT.proto doStopPump($(P)) $(port)")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# Rev from Normal speed (or stopped?) to Standby speed.
record(bo, "$(P):ACN:STANDBY") {
  field(DESC, "Standby speed on action.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(VAL, "1")
  field(OUT,  "@EdNxtT.proto doStandbySpeed($(P)) $(port)")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# Rev from Standby speed to full speed.
record(bo, "$(P):ACN:FULL") {
  field(DESC, "Full speed - Standby off action.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(VAL, "1")
  field(OUT,  "@EdNxtT.proto doFullSpeed($(P)) $(port)")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# Reset the runtime and time to service for the pump bearing.
# This should only be done just after the bearing has been
# replaced, but there is no protection on this feature.
# See section p.18 of section 7.3 of Service Manual RevB.
record(bo, "$(P):SVC:RESET:BEARING") {
  field(DESC, "Reset bearing service timers")
  field(DTYP, "stream")
  field(SCAN, "Passive")
# Explicitly state we do NOT want this processed on initialisation.
  field(PINI, "NO")
  field(VAL, "1")
  field(OUT,  "@EdNxtT.proto doResetSvcBrng($(P)) $(port)")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# Reset the runtime and time to service for the oil cartridge.
# This should only be done just after the oil cartridge
# replaced, but there is no protection on this feature.
# See section p.18 of section 7.3 of Service Manual RevB.
record(bo, "$(P):SVC:RESET:OIL") {
  field(DESC, "Reset oil cartridge service timers")
  field(DTYP, "stream")
  field(SCAN, "Passive")
# Explicitly state we do NOT want this processed on initialisation.
  field(PINI, "NO")
  field(VAL, "1")
  field(OUT,  "@EdNxtT.proto doResetSvcOil($(P)) $(port)")
  field(FLNK, "$(P):RTN:LASTCMD PP MS")
}

# END OF RECORDS TO DO STUFF.
##################################################################
# START OF RECORDS TO SUPPORT GUI.


# END OF RECORDS TO SUPPORT GUI.
##################################################################
# START OF RECORDS TO MANGLE MOTOR SPEEDS.
#

# Conversion of motor speeds from percentage units to rps units.
record(transform, "$(P):TFM:SPEEDS:PCTORPS") {
  field(SCAN, "Passive")
  field(CMTA, "Conversion factor (rps).")
  field(INPA, "$(P):VSN:FULLSPEED:RPS")
  field(CMTB, "Normal motor speed %.")
  field(INPB, "$(P):RBV:NORMALSPEED:PC")
  field(CMTC, "Standby motor speed %.")
  field(INPC, "$(P):RBV:STANDBYSPEED:PC")
  field(CMTD, "Normal motor speed rps.")
  field(CLCD, "A*B/100")
  field(OUTD, "$(P):RBV:NORMALSPEED:RPS PP MS")
  field(CMTE, "Standby motor speed rps.")
  field(CLCE, "A*C/100")
  field(OUTE, "$(P):RBV:STANDBYSPEED:RPS PP MS")
}

record(ai, "$(P):RBV:NORMALSPEED:RPS") {
  field(DESC, "Normal Speed of Motor (rps).")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "RPS")
  field(PREC, "0")
}

record(ai, "$(P):RBV:STANDBYSPEED:RPS") {
  field(DESC, "Standby Speed of Motor (rps).")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "RPS")
  field(PREC, "0")
}

# Conversion of current motor speed status from RPS to percentage.
# We only have one of these to do, if more are needed will need a 
# transform record.
record(calcout, "$(P):CLC:MOTORSPEED:RPSTOPC") {
  field(SCAN, "Passive")
  field(INPA, "$(P):VSN:FULLSPEED:RPS")
  field(INPB, "$(P):STS:MOTORSPEED:RPS")
  field(CALC,  "B*100/A")
  field(OUT, "$(P):STS:MOTORSPEED:PC PP MS")
}

record(ai, "$(P):STS:MOTORSPEED:PC") {
  field(DESC, "Current Speed of Motor (rps).")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(EGU,  "%")
  field(PREC, "1")
}

# END OF RECORDS TO MANGLE MOTOR SPEEDS.
##################################################################
# START OF ERROR HANDLING
#
# Record to receive the error code from the last command that returns one.
# See Table 18 - Error Codes on p. 44. of the Instruction Manual RevC.
record(mbbi, "$(P):RTN:LASTCMD" ) {
  field(DESC, "Return code from last command sent.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZRST, "No error")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "Bad obj ID cmd")
  field(ONVL, "1")
  field(ONSV, "MINOR")
  field(TWST, "Bad query/cmd")
  field(TWVL, "2")
  field(TWSV, "MINOR")
  field(THST, "Missing param")
  field(THVL, "3")
  field(THSV, "MINOR")
  field(FRST, "Param out of range")
  field(FRVL, "4")
  field(FRSV, "MINOR")
  field(FVST, "Invalid state change")
  field(FVVL, "5")
  field(FVSV, "MINOR")
}

# END OF ERROR HANDLING
##################################################################
